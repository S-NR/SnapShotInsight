<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ðŸ›  STM32 Clock Training Guide</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>  
    <div class="overlay">

    <div class="header">
        <h1>ðŸ›  Step-by-Step Training: Clocks & Oscillators on STM32</h1>
    </div>
    <div class="section">
        <h2>Prerequisites</h2>
        <ul>
            <li>STM32 board (e.g., STM32F103C8T6 / Nucleo / Discovery)</li>
            <li>STM32CubeMX + STM32CubeIDE</li>
            <li>External crystal soldered (if not on Nucleo)</li>
            <li>Multimeter / oscilloscope (optional)</li>
        </ul>

    <h2>âœ… Step 1: Blink LED using Internal Clock (HSI)</h2>
    <p><strong>Goal:</strong> </p>
    <p>Use HSI (~8 MHz) to blink LED every 1s.</p>
    <p><strong>STM32CubeMX Setup:</strong> </p>
    <ul>
        <li>RCC : HSI selected</li>
        <li>GPIO: Configure LED pin as output (e.g., PC13 on STM32F103)</li>
        <li>SysTick: Use default HAL tick based on HSI</li>
    </ul> 
    <pre><code>int main(void)
{
  HAL_Init();
  SystemClock_Config();  // Generated by CubeMX
  __HAL_RCC_GPIOC_CLK_ENABLE();

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  GPIO_InitStruct.Pin = GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  while (1)
  {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
    HAL_Delay(1000);  // 1 second
  }
}</code></pre>
    <p><strong>Result :</strong></p>
    <p>Observe 1 Hz blinking with internal oscillator.</p>

    <h2>âœ… Step 2: Switch to External Crystal (HSE)</h2>

    <p><strong>Goal:</strong> </p>
    <p>Configure system clock using external 8 MHz crystal.</p>
    <p><strong>STM32CubeMX Setup:</strong> </p>
    <ul>
        <li>Enable HSE in RCC</li>
        <li>Disable PLL</li>
        <li>Set system clock source = HSE</li>
    </ul> 
    <pre><code>RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_OFF;</code></pre>
    <p><strong>Result :</strong></p>
    <p>LED blinks at same 1 Hz, but now based on more stable crystal clock.</p>

    <h2>âœ… Step 3: Enable PLL (HSE Ã— 9 = 72 MHz)</h2>

    <p><strong>Goal:</strong> </p>
    <p>Boost system clock to 72 MHz using PLL.</p>
    <p><strong>STM32CubeMX Setup:</strong> </p>
    <ul>
        <li>HSE = 8 MHz</li>
        <li>PLL MUL = 9</li>
        <li>SYSCLK = PLL output (72 MHz)</li>
    </ul> 
    <pre><code>RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;

RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</code></pre>
    <p><strong>Result:</strong> </p>
    <ul>
        <li>MCU runs at 72 MHz</li>
        <li>HAL_Delay uses this clock for millisecond timing</li>
        <li>LED still blinks at 1 Hz</li>
    </ul> 

    <h2>âœ… Step 4: Use DWT Cycle Counter to Measure Execution Time</h2>
    <p><strong>Goal:</strong></p> 
    <p>Generate precise microsecond delays and verify.</p>
    <pre><code>#include "core_cm3.h"

void delay_us(uint32_t us)
{
    DWT->CTRL |= 1; // Enable the DWT counter
    uint32_t start = DWT->CYCCNT;
    uint32_t ticks = us * (SystemCoreClock / 1000000);
    while ((DWT->CYCCNT - start) < ticks);
}</code></pre>
<p><strong>Result:</strong> </p>
<p>Use this to show exact 100 Âµs or 1 ms delay and how it's affected by frequency.</p>

    <h2>âœ… Step 5: Clock Failure Fallback (HSE â†’ HSI)</h2>
    <p><strong>Goal:</strong></p> 
    <p>Detect HSE failure and switch to HSI.</p>
    <pre><code>// In error handler
HAL_RCC_DeInit();
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);</code></pre>
    <p><strong>Result:</strong> </p>
    <ul>
        <li>Blink LED faster to indicate fallback</li>
        <li>Set error LED or send message on UART</li>
    </ul> 

    <h2>âœ… Step 6: Use RTC with LSE (32.768 kHz)</h2>
    <p><strong>Goal:</strong></p> 
    <p>Configure RTC using LSE for real-time tracking. Use 32.768 kHz crystal on LSE pins to configure RTC.</p>
    <p><strong>STM32CubeMX Setup:</strong> </p>
    <ul>
        <li>Enable LSE</li>
        <li>Enable RTC</li>
        <li>Show time on UART every second</li>
    </ul> 
    <pre><code>RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
HAL_RCC_OscConfig(&RCC_OscInitStruct);</code></pre>

    <h2>ðŸ“Š Clock Measurement with Oscilloscope</h2>
    <ul>
      <li>CH1 â†’ LED pin (check 1Hz square wave)</li>
      <li>CH2 â†’ XTAL pin (verify 8 MHz sine wave)</li>
      <li>Use cursor tool to verify pulse width, frequency, jitter</li>
    </ul>

    <h2>ðŸ“‹ Summary Table</h2>
    <table>
      <thead>
        <tr><th>Step</th><th>Description</th><th>Clock Source</th></tr>
      </thead>
      <tbody>
        <tr><td>1</td><td>Blink with internal oscillator</td><td>HSI</td></tr>
        <tr><td>2</td><td>Switch to external crystal</td><td>HSE</td></tr>
        <tr><td>3</td><td>Enable PLL</td><td>HSE Ã— 9 = 72 MHz</td></tr>
        <tr><td>4</td><td>Measure using DWT</td><td>SYSCLK</td></tr>
        <tr><td>5</td><td>Clock failure fallback</td><td>HSI</td></tr>
        <tr><td>6</td><td>RTC ticking</td><td>LSE</td></tr>
      </tbody>
    </table>

    <div class="note">
      ðŸ’¡ Tip: You can also toggle a GPIO inside a tight loop to measure real-time toggling frequency with oscilloscope.
    </div>
  </div>
</div>
</body>
</html>
