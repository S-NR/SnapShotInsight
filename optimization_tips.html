<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üîß Code Memory vs Data Memory in Embedded Systems</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      background-color: #f9f9f9;
      color: #222;
      line-height: 1.7;
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    code {
      background: #eee;
      padding: 2px 5px;
      border-radius: 4px;
    }
    pre {
      background: #272822;
      color: #f8f8f2;
      padding: 15px;
      overflow-x: auto;
      border-radius: 6px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 10px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    .section {
      margin-top: 40px;
    }
  </style>
</head>
<body>

  <h1>üîß Code Memory vs Data Memory in Embedded Systems</h1>
  <p><strong>Deep Dive for Freshers with Practical C Examples</strong></p>

  <div class="section">
    <h2>üîπ First: Understand the Two Key Memories</h2>
    <table>
      <thead>
        <tr>
          <th>Memory Type</th>
          <th>Location</th>
          <th>Volatile?</th>
          <th>What It Stores</th>
          <th>Example Use</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Program Memory (Flash/ROM)</td>
          <td>Non-volatile</td>
          <td>‚ùå</td>
          <td>Code, constant strings, lookup tables</td>
          <td><code>const char *msg = "Hi";</code></td>
        </tr>
        <tr>
          <td>Data Memory (RAM/SRAM)</td>
          <td>Volatile</td>
          <td>‚úÖ</td>
          <td>Variables, buffers, function stack frames</td>
          <td><code>int x = 10;</code></td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>‚úÖ 1. Program Memory Optimization</h2>
    <h3>üß™ Example 1: const keyword usage</h3>
    <pre><code>const char welcome_msg[] = "Welcome!";</code></pre>
    <p><strong>Explanation:</strong> <code>const</code> tells the compiler to store in Flash. Saves RAM.</p>

    <h3>üß™ Example 2: Flash lookup table vs runtime computation</h3>
    <pre><code>// Good (Flash usage)
const uint8_t square_lookup[] = {0, 1, 4, 9, 16, 25};
uint8_t result = square_lookup[input];

// Bad
uint8_t result = input * input;</code></pre>

    <h3>üß™ Example 3: Avoid duplicated logic</h3>
    <pre><code>// Bad:
led_on(); delay(100); led_off();
led_on(); delay(100); led_off();

// Good:
void blink_once(void) {
  led_on();
  delay(100);
  led_off();
}
blink_once();
blink_once();</code></pre>
  </div>

  <div class="section">
    <h2>‚úÖ 2. Data Memory Optimization (RAM/SRAM)</h2>

    <h3>üß™ Example 4: Global vs Local variables</h3>
    <pre><code>// Global buffer
uint8_t buffer[1024];

// Local buffer
void process() {
  uint8_t buffer[256];
}</code></pre>

    <h3>üß™ Example 5: Smaller data types</h3>
    <pre><code>uint8_t count = 0;      // 1 byte
uint16_t id = 1000;     // 2 bytes
uint32_t total = 10000; // 4 bytes</code></pre>

    <h3>üß™ Example 6: Bit-fields (RAM compression)</h3>
    <pre><code>// Full-size
struct Flags {
  uint8_t a;
  uint8_t b;
  uint8_t c;
};

// Compressed
struct Flags {
  uint8_t a : 1;
  uint8_t b : 1;
  uint8_t c : 1;
};</code></pre>

    <h3>üß™ Example 7: String stored in RAM vs Flash</h3>
    <pre><code>// RAM
char msg[] = "Hello";

// Flash
const char *msg = "Hello";</code></pre>
  </div>

  <div class="section">
    <h2>‚úÖ 3. Combined Optimization (Code + Data Memory)</h2>

    <h3>üß™ Example 8: Reusing Buffers</h3>
    <pre><code>// Bad
uint8_t uart_buffer[128];
uint8_t i2c_buffer[128];

// Good
uint8_t shared_buffer[128];</code></pre>

    <h3>üß™ Example 9: Use static for persistent local data</h3>
    <pre><code>void counter() {
  static int count = 0;
  count++;
}</code></pre>
  </div>

  <div class="section">
    <h2>‚úÖ 4. Program vs Data Memory with Microcontroller Specific Keywords</h2>
    <pre><code>#include &lt;avr/pgmspace.h&gt;
const char msg[] PROGMEM = "Flash string";
char buffer[20];
strcpy_P(buffer, msg);</code></pre>
  </div>

  <div class="section">
    <h2>‚úÖ 5. EEPROM Memory (Config settings)</h2>
    <pre><code>#include &lt;avr/eeprom.h&gt;

uint8_t EEMEM stored_value;

void write_value(uint8_t val) {
  eeprom_write_byte(&stored_value, val);
}

uint8_t read_value() {
  return eeprom_read_byte(&stored_value);
}</code></pre>
    <p><strong>Note:</strong> EEPROM is non-volatile but slow. Avoid frequent writes.</p>
  </div>

  <div class="section">
    <h2>üóö Summary Table</h2>
    <table>
      <thead>
        <tr>
          <th>Optimization Type</th>
          <th>Techniques</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Program Memory</td>
          <td>const, remove duplication, use Flash tables, avoid inlining</td>
        </tr>
        <tr>
          <td>Data Memory (RAM)</td>
          <td>Bit-fields, reuse buffers, local over global, size types</td>
        </tr>
        <tr>
          <td>Both Combined</td>
          <td>Move const to Flash, share buffers, optimize algorithms</td>
        </tr>
        <tr>
          <td>EEPROM</td>
          <td>For settings; avoid frequent writes</td>
        </tr>
      </tbody>
    </table>
  </div>

</body>
</html>
